<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Happy 8th Birthday Henry! - Monkey Game</title>
  <style>
    :root {
      color-scheme: light;
      font-family: 'Nunito', 'Segoe UI', Tahoma, sans-serif;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      padding: 32px 16px 64px;
      background: linear-gradient(180deg, #ffd6e8 0%, #ffe0f0 50%, #fff4f8 100%);
      color: #5a2d4a;
    }

    h1 {
      margin: 0;
      font-size: clamp(2rem, 5vw, 3.5rem);
      letter-spacing: 0.05em;
      color: #ff6b9d;
      text-shadow: 0 4px 12px rgba(255, 107, 157, 0.3);
      font-weight: 800;
      text-align: center;
    }

    .tagline {
      margin: 0;
      font-size: clamp(1rem, 2vw, 1.3rem);
      color: #8b4a6b;
      text-align: center;
      max-width: 700px;
      font-weight: 600;
    }

    .hud {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: clamp(20px, 4vw, 40px);
      font-size: clamp(1rem, 2vw, 1.3rem);
      font-weight: 700;
    }

    .hud span {
      color: #ff6b9d;
      margin-left: 8px;
      font-size: 1.2em;
    }

    /* Description Page Styles */
    .description-page {
      width: 100%;
      max-width: 900px;
      margin: 0 auto;
    }

    .description-content {
      background: white;
      border-radius: 28px;
      padding: 40px;
      box-shadow: 0 20px 60px rgba(255, 107, 157, 0.3);
    }

    .description-content h2 {
      text-align: center;
      font-size: clamp(2rem, 5vw, 3rem);
      color: #ff6b9d;
      margin-bottom: 30px;
    }

    .game-preview {
      margin: 30px 0;
      border-radius: 20px;
      overflow: hidden;
      border: 4px solid rgba(255, 107, 157, 0.4);
    }

    .preview-image {
      position: relative;
      width: 100%;
      aspect-ratio: 16 / 9;
      background: linear-gradient(180deg, #87ceeb 0%, #ffd6e8 60%, #ffb3d9 100%);
    }

    #previewCanvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    .game-info {
      margin-top: 30px;
    }

    .game-info h3 {
      font-size: 1.5rem;
      color: #ff6b9d;
      margin-bottom: 15px;
    }

    .game-info ul {
      list-style: none;
      padding: 0;
      margin: 0 0 30px 0;
    }

    .game-info li {
      padding: 10px 0;
      border-bottom: 1px solid rgba(255, 107, 157, 0.2);
      color: #5a2d4a;
      font-size: 1rem;
      line-height: 1.6;
    }

    .game-info li:last-child {
      border-bottom: none;
    }

    .start-button {
      width: 100%;
      padding: 24px;
      font-size: 1.5rem;
      font-weight: 700;
      color: white;
      background: linear-gradient(135deg, #ff6b9d 0%, #ff8fb3 100%);
      border: none;
      border-radius: 999px;
      cursor: pointer;
      box-shadow: 0 8px 24px rgba(255, 107, 157, 0.4);
      transition: transform 0.2s, box-shadow 0.2s;
      touch-action: manipulation; /* Allow button clicks on touch */
    }

    .start-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 32px rgba(255, 107, 157, 0.5);
    }

    .start-button:active {
      transform: translateY(0);
    }

    .hidden {
      display: none !important;
    }

    .stage {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(180deg, #87ceeb 0%, #ffd6e8 60%, #ffb3d9 100%);
      touch-action: none; /* Prevent default touch behaviors when game is running */
      z-index: 9999;
    }
    
    /* When embedded, use relative positioning instead of fixed */
    .stage.embedded {
      position: relative;
      width: 100%;
      height: 100%;
      min-height: 400px;
      aspect-ratio: 16 / 9;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none;
      cursor: pointer;
    }

    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(255, 255, 255, 0.98);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 20px;
      padding: 24px;
      text-align: center;
      z-index: 10;
    }

    .overlay.hidden {
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .overlay h2 {
      margin: 0;
      font-size: clamp(2rem, 4vw, 3rem);
      color: #ff6b9d;
      font-weight: 800;
    }

    .overlay p {
      margin: 0;
      color: #5a2d4a;
      line-height: 1.6;
      font-size: clamp(1rem, 2vw, 1.2rem);
    }

    .overlay button {
      padding: 18px 36px;
      font-size: 1.3rem;
      font-weight: 700;
      color: white;
      background: linear-gradient(135deg, #ff6b9d 0%, #ff8fb3 100%);
      border: none;
      border-radius: 999px;
      cursor: pointer;
      box-shadow: 0 8px 24px rgba(255, 107, 157, 0.4);
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .overlay button:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 32px rgba(255, 107, 157, 0.5);
    }

    .overlay button:active {
      transform: translateY(0);
    }

    .heart {
      display: inline-block;
      color: #ff6b9d;
      animation: float 2s ease-in-out infinite;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    /* Hide body scroll when in game */
    body.game-running {
      overflow: hidden;
    }
  </style>
</head>
<body>
  <h1>üéâ Happy 8th Birthday Henry! üéâ</h1>
  <p class="tagline">Jump and catch balloons while avoiding snapping crocodiles! <span class="heart">üíù</span></p>

  <div class="hud" role="status" aria-live="polite">
    <div>Balloons:<span id="score">0</span></div>
    <div>Lives:<span id="lives">3</span></div>
    <div>Best:<span id="best">0</span></div>
  </div>

  <!-- Game Description Page (shown before fullscreen) -->
  <div id="descriptionPage" class="description-page">
    <div class="description-content">
      <h2>üéÇ Happy 8th Birthday Henry! üéÇ</h2>
      <div class="game-preview">
        <div class="preview-image">
          <canvas id="previewCanvas" width="900" height="506"></canvas>
        </div>
      </div>
      <div class="game-info">
        <h3>How to Play</h3>
        <ul>
          <li><strong>Desktop:</strong> Use arrow keys (‚Üê ‚Üí) to move, SPACE or ‚Üë to jump</li>
          <li><strong>Mobile/Touch:</strong> Drag anywhere to move, tap anywhere to jump</li>
          <li>Catch colorful balloons to earn points</li>
          <li>Avoid the snapping crocodiles - they'll take a life!</li>
          <li>Jump on a crocodile's back for a boost (if you're brave!)</li>
          <li>Special balloons give you power-ups like shields and slow motion</li>
        </ul>
        <button id="startBtn" class="start-button">Start Game (Fullscreen)</button>
      </div>
    </div>
  </div>

  <!-- Fullscreen Game Stage (hidden until game starts) -->
  <div class="stage hidden" id="stage">
    <canvas id="game" width="900" height="506" aria-label="Happy 8th Birthday Henry Monkey game"></canvas>
    
    <div id="gameOverOverlay" class="overlay hidden">
      <h2 id="gameOverTitle">Game Over!</h2>
      <p id="gameOverText">You caught <span id="finalScore">0</span> balloons!</p>
      <button id="restartBtn">Play Again</button>
      <button id="exitFullscreenBtn">Exit Fullscreen</button>
    </div>
  </div>

  <script type="module">
    (() => {
      // Detect if game is embedded (in an iframe or injected into a container div)
      const isEmbedded = (() => {
        // Check if in iframe
        try {
          if (window.self !== window.top) return true;
        } catch (e) {
          // Cross-origin iframe - treat as embedded
          return true;
        }
        // Check if we're inside a container that's not the full viewport
        // When GamePlayer injects, our body might be in a div
        const bodyParent = document.body.parentElement;
        if (bodyParent && bodyParent !== document.documentElement) {
          // Check if parent has specific classes from GamePlayer
          const parentClasses = bodyParent.className || '';
          if (parentClasses.includes('game-viewport') || parentClasses.includes('game-content')) {
            return true;
          }
        }
        // Check body itself for container indicators
        const bodyRect = document.body.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        // If body height is significantly less than viewport, likely embedded
        if (bodyRect.height > 0 && bodyRect.height < viewportHeight * 0.9) {
          return true;
        }
        return false;
      })();
      
      // ERROR HANDLING AND LOGGING
      const ERROR_LOG = [];
      function logError(category, message, error = null) {
        const entry = {
          time: new Date().toISOString(),
          category,
          message,
          error: error ? { name: error.name, message: error.message, stack: error.stack } : null,
          userAgent: navigator.userAgent,
          touchDevice: 'ontouchstart' in window || navigator.maxTouchPoints > 0,
          fullscreen: !!document.fullscreenElement,
          windowSize: { w: window.innerWidth, h: window.innerHeight },
          embedded: isEmbedded
        };
        ERROR_LOG.push(entry);
        console.error(`[${category}]`, message, error || '');
        
        // Show critical errors to user
        if (category === 'CRITICAL') {
          alert(`Game Error: ${message}\n\nCheck console for details.`);
        }
      }

      window.addEventListener('error', (e) => {
        logError('JAVASCRIPT_ERROR', `${e.message} at ${e.filename}:${e.lineno}:${e.colno}`, e.error);
      });

      window.addEventListener('unhandledrejection', (e) => {
        logError('PROMISE_REJECTION', e.reason?.message || String(e.reason), e.reason);
      });

      // Export for testing
      window.GAME_ERROR_LOG = ERROR_LOG;

      try {
        const canvas = document.getElementById('game');
        if (!canvas) {
          logError('CRITICAL', 'Canvas element not found', null);
          return;
        }
        const ctx = canvas.getContext('2d');
        if (!ctx) {
          logError('CRITICAL', 'Could not get canvas 2d context', null);
          return;
        }
        
        const previewCanvas = document.getElementById('previewCanvas');
        const previewCtx = previewCanvas?.getContext('2d');
        const stage = document.getElementById('stage');
        if (!stage) {
          logError('CRITICAL', 'Stage element not found', null);
          return;
        }
        const descriptionPage = document.getElementById('descriptionPage');
        if (!descriptionPage) {
          logError('CRITICAL', 'Description page element not found', null);
          return;
        }
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const startBtn = document.getElementById('startBtn');
        if (!startBtn) {
          logError('CRITICAL', 'Start button not found', null);
          return;
        }
        const restartBtn = document.getElementById('restartBtn');
        const exitFullscreenBtn = document.getElementById('exitFullscreenBtn');
        const scoreEl = document.getElementById('score');
        const livesEl = document.getElementById('lives');
        const bestEl = document.getElementById('best');
        const finalScoreEl = document.getElementById('finalScore');
        const gameOverTitle = document.getElementById('gameOverTitle');
        const gameOverText = document.getElementById('gameOverText');

      const W = canvas.width;
      const H = canvas.height;
      const GROUND_Y = H - 100;

      // DIFFICULTY CONFIGURATION FOR 10-YEAR-OLDS
      const DIFFICULTY = {
        gravity: 1.3,
        jumpPower: -19,
        balloonSpawnBase: 600,
        balloonSpawnMin: 250,
        balloonSpawnScaling: 10,
        crocSpawnBase: 2000,
        crocSpawnMin: 800,
        crocSpawnScaling: 40,
        shieldDuration: 5,
        slowMoDuration: 4,
        collisionTolerance: 0.85,
        crocJumpBuffer: 5,
        monkeySpeed: 8,
        baseGameSpeed: 1,
        speedIncrease: 0.025,
      };

      // Detect touch device
      const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

      // SVG Images
      function createMonkeySVG(frame) {
        const legOffset = Math.sin(frame * 0.5) * 8;
        const armOffset = Math.sin(frame * 0.5 + Math.PI) * 6;
        return 'data:image/svg+xml;base64,' + btoa(`
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
            <ellipse cx="50" cy="58" rx="22" ry="28" fill="#d4a574"/>
            <ellipse cx="50" cy="68" rx="20" ry="24" fill="#c89664"/>
            <path d="M 45 20 L 50 8 L 55 20" fill="#ff6b9d"/>
            <circle cx="50" cy="8" r="3" fill="#ffd700"/>
            <rect x="44" y="20" width="12" height="8" fill="#ff6b9d"/>
            <circle cx="50" cy="35" r="20" fill="#d4a574"/>
            <ellipse cx="50" cy="32" rx="18" ry="19" fill="#e6b884"/>
            <ellipse cx="44" cy="30" rx="5" ry="6" fill="#000"/>
            <ellipse cx="56" cy="30" rx="5" ry="6" fill="#000"/>
            <circle cx="45" cy="30" r="2" fill="#fff"/>
            <circle cx="57" cy="30" r="2" fill="#fff"/>
            <ellipse cx="50" cy="38" rx="3" ry="2" fill="#000"/>
            <path d="M 48 42 Q 50 46 52 42" stroke="#000" stroke-width="2" fill="none" stroke-linecap="round"/>
            <circle cx="32" cy="32" r="12" fill="#d4a574"/>
            <circle cx="68" cy="32" r="12" fill="#d4a574"/>
            <circle cx="32" cy="32" r="8" fill="#c89664"/>
            <circle cx="68" cy="32" r="8" fill="#c89664"/>
            <circle cx="${30 + armOffset}" cy="52" r="10" fill="#d4a574"/>
            <circle cx="${70 - armOffset}" cy="52" r="10" fill="#d4a574"/>
            <ellipse cx="${26 + armOffset}" cy="58" rx="6" ry="8" fill="#c89664"/>
            <ellipse cx="${74 - armOffset}" cy="58" rx="6" ry="8" fill="#c89664"/>
            <ellipse cx="${42 + legOffset}" cy="85" rx="8" ry="10" fill="#c89664"/>
            <ellipse cx="${58 - legOffset}" cy="85" rx="8" ry="10" fill="#c89664"/>
            <ellipse cx="50" cy="60" rx="12" ry="16" fill="#e6b884"/>
          </svg>
        `);
      }

      const balloonColors = ['#ff6b9d', '#ffb347', '#87ceeb', '#ffd700', '#ff69b4', '#32cd32', '#ff1493', '#ff6347'];
      
      const number8BalloonSVG = 'data:image/svg+xml;base64,' + btoa(`
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 80">
          <ellipse cx="30" cy="35" rx="25" ry="30" fill="#ff6b9d"/>
          <ellipse cx="30" cy="30" rx="18" ry="20" fill="#ff8fb3" opacity="0.8"/>
          <text x="30" y="40" font-family="Arial Black" font-size="24" font-weight="900" fill="#fff" text-anchor="middle">8</text>
          <line x1="30" y1="60" x2="30" y2="75" stroke="#654321" stroke-width="2"/>
          <path d="M 15 30 Q 30 20 45 30" stroke="#fff" stroke-width="2" fill="none" opacity="0.6"/>
        </svg>
      `);

      const balloonSVGs = balloonColors.map(color => 
        'data:image/svg+xml;base64,' + btoa(`
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 80">
            <defs>
              <linearGradient id="balloonGrad${color.replace('#', '')}" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:${color};stop-opacity:1" />
                <stop offset="100%" style="stop-color:${color};stop-opacity:0.7" />
              </linearGradient>
            </defs>
            <ellipse cx="30" cy="35" rx="25" ry="30" fill="url(#balloonGrad${color.replace('#', '')})"/>
            <ellipse cx="30" cy="28" rx="18" ry="22" fill="#fff" opacity="0.4"/>
            <line x1="30" y1="60" x2="30" y2="75" stroke="#654321" stroke-width="2"/>
            <path d="M 15 30 Q 30 18 45 30" stroke="#fff" stroke-width="2.5" fill="none" opacity="0.5"/>
          </svg>
        `)
      );

      function createCrocSVG(frame) {
        const legOffset = Math.sin(frame * 0.8) * 10;
        return 'data:image/svg+xml;base64,' + btoa(`
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 140 70">
            <defs>
              <linearGradient id="crocGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:#32cd32;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#228b22;stop-opacity:1" />
              </linearGradient>
            </defs>
            <ellipse cx="70" cy="35" rx="60" ry="30" fill="url(#crocGrad)"/>
            <rect x="25" y="25" width="90" height="22" rx="10" fill="#228b22"/>
            <circle cx="50" cy="30" r="8" fill="#ffd700"/>
            <circle cx="90" cy="30" r="8" fill="#ffd700"/>
            <circle cx="52" cy="30" r="4" fill="#000"/>
            <circle cx="92" cy="30" r="4" fill="#000"/>
            <circle cx="53" cy="29" r="1.5" fill="#fff"/>
            <circle cx="93" cy="29" r="1.5" fill="#fff"/>
            <circle cx="40" cy="32" r="2" fill="#000"/>
            <circle cx="100" cy="32" r="2" fill="#000"/>
            <path d="M 20 35 L 25 30 L 25 35 Z" fill="#fff"/>
            <path d="M 115 35 L 120 30 L 120 35 Z" fill="#fff"/>
            <path d="M 22 38 L 25 35 L 25 38 Z" fill="#fff"/>
            <path d="M 118 38 L 120 35 L 120 38 Z" fill="#fff"/>
            <path d="M 30 45 Q 35 50 40 45 M 45 45 Q 50 50 55 45 M 60 45 Q 65 50 70 45 M 75 45 Q 80 50 85 45 M 90 45 Q 95 50 100 45" stroke="#228b22" stroke-width="3" fill="none"/>
            <ellipse cx="${35 + legOffset}" cy="62" rx="6" ry="8" fill="#228b22"/>
            <ellipse cx="${55 - legOffset}" cy="62" rx="6" ry="8" fill="#228b22"/>
            <ellipse cx="${85 + legOffset}" cy="62" rx="6" ry="8" fill="#228b22"/>
            <ellipse cx="${105 - legOffset}" cy="62" rx="6" ry="8" fill="#228b22"/>
            <path d="M 18 38 Q 25 35 35 38" stroke="#ff6347" stroke-width="4" fill="none" stroke-linecap="round"/>
            <path d="M 105 38 Q 115 35 122 38" stroke="#ff6347" stroke-width="4" fill="none" stroke-linecap="round"/>
          </svg>
        `);
      }

      const backgroundLayers = [
        { offset: 0, speed: 0.15, color: '#b0d4f0', yPos: 0, height: 0.25 },
        { offset: 0, speed: 0.35, color: '#d4e8f0', yPos: 0.25, height: 0.25 },
        { offset: 0, speed: 0.6, color: '#ffd6e8', yPos: 0.5, height: 0.35 },
      ];

      const state = {
        running: false,
        score: 0,
        lives: 3,
        best: parseInt(localStorage.getItem('henryMonkeyBest') || '0'),
        monkey: { 
          x: W / 2 - 30, 
          y: GROUND_Y, 
          width: 60, 
          height: 100, 
          speed: DIFFICULTY.monkeySpeed,
          vx: 0,
          vy: 0,
          isJumping: false,
          onGround: true,
          walkFrame: 0
        },
        balloons: [],
        crocodiles: [],
        decorations: [],
        particles: [],
        effects: [],
        lastBalloonTime: 0,
        lastCrocTime: 0,
        lastTime: 0,
        gravity: DIFFICULTY.gravity,
        jumpPower: DIFFICULTY.jumpPower,
        gameSpeed: DIFFICULTY.baseGameSpeed,
        combo: 0,
        comboTimer: 0,
        multiplier: 1,
        shield: false,
        shieldTimer: 0,
        slowMotion: false,
        slowMotionTimer: 0,
        screenShake: 0,
        lastComboTime: 0,
        canvasW: W,
        canvasH: H,
        groundY: GROUND_Y,
      };

      const keys = {};
      
      // NEW DRAG-TO-MOVE & TAP-TO-JUMP TOUCH SYSTEM
      const touches = new Map(); // touchId -> { startX, startY, currentX, currentY, startTime, isDrag }
      let dragVelocity = 0; // Current horizontal drag velocity (-1 to 1)
      const DRAG_THRESHOLD = 15; // Pixels of movement to count as drag vs tap (increased for better detection)
      const TAP_TIME_THRESHOLD = 300; // Max ms for a tap (increased for easier taps)
      const DRAG_SENSITIVITY = 0.04; // How responsive dragging is (doubled for better responsiveness)

      // PRE-CACHE ALL IMAGES
      const imageCache = {
        monkeyFrames: [],
        crocFrames: [],
        balloons: [],
        number8Balloon: new Image(),
      };

      for (let i = 0; i < 8; i++) {
        const monkeyImg = new Image();
        monkeyImg.src = createMonkeySVG(i);
        imageCache.monkeyFrames.push(monkeyImg);
        
        const crocImg = new Image();
        crocImg.src = createCrocSVG(i);
        imageCache.crocFrames.push(crocImg);
      }

      imageCache.balloons = balloonSVGs.map(src => {
        const img = new Image();
        img.src = src;
        return img;
      });

      imageCache.number8Balloon.src = number8BalloonSVG;

      function createDecorations() {
        state.decorations = [];
        for (let i = 0; i < 20; i++) {
          state.decorations.push({
            x: Math.random() * state.canvasW,
            y: Math.random() * state.canvasH,
            type: Math.random() > 0.5 ? 'confetti' : 'star',
            rotation: Math.random() * Math.PI * 2,
            speed: 0.02 + Math.random() * 0.03,
            size: 8 + Math.random() * 12,
            depth: Math.random(),
          });
        }
      }

      function requestFullscreen() {
        const elem = stage;
        if (elem.requestFullscreen) {
          return elem.requestFullscreen().catch(() => {});
        } else if (elem.webkitRequestFullscreen) {
          return Promise.resolve(elem.webkitRequestFullscreen());
        } else if (elem.msRequestFullscreen) {
          return Promise.resolve(elem.msRequestFullscreen());
        } else if (elem.mozRequestFullScreen) {
          return Promise.resolve(elem.mozRequestFullScreen());
        }
        return Promise.resolve();
      }

      function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        const displayWidth = rect.width;
        const displayHeight = rect.height;
        
        if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
          canvas.width = displayWidth;
          canvas.height = displayHeight;
          
          state.canvasW = displayWidth;
          state.canvasH = displayHeight;
          state.groundY = displayHeight - 100;
          
          if (state.running) {
            state.monkey.y = state.groundY;
            state.monkey.x = Math.max(0, Math.min(state.canvasW - state.monkey.width, state.monkey.x));
          }
        }
      }

      document.addEventListener('fullscreenchange', () => {
        setTimeout(resizeCanvas, 100);
      });
      document.addEventListener('webkitfullscreenchange', () => {
        setTimeout(resizeCanvas, 100);
      });
      document.addEventListener('mozfullscreenchange', () => {
        setTimeout(resizeCanvas, 100);
      });
      document.addEventListener('MSFullscreenChange', () => {
        setTimeout(resizeCanvas, 100);
      });
      
      window.addEventListener('resize', resizeCanvas);

      Promise.all([
        ...imageCache.monkeyFrames.map(img => new Promise(resolve => { 
          img.onload = resolve; 
          img.onerror = resolve; 
        })),
        ...imageCache.balloons.map(img => new Promise(resolve => { 
          img.onload = resolve; 
          img.onerror = resolve; 
        })),
        new Promise(resolve => { 
          imageCache.number8Balloon.onload = resolve; 
          imageCache.number8Balloon.onerror = resolve; 
        }),
        ...imageCache.crocFrames.map(img => new Promise(resolve => { 
          img.onload = resolve; 
          img.onerror = resolve; 
        })),
      ]).then(() => {
        createDecorations();
        if (!state.running) {
          drawPreview(); // Draw preview on description page
          draw(); // Also draw on main canvas (will be hidden)
        }
      });

      // INTUITIVE DRAG-TO-MOVE & TAP-TO-JUMP TOUCH CONTROLS
      function getTouchPosition(touch) {
        const rect = canvas.getBoundingClientRect();
        return {
          x: touch.clientX - rect.left,
          y: touch.clientY - rect.top
        };
      }

      // Attach touch events to both canvas AND stage (for better compatibility)
      // NOTE: Touch events only work when game is running (after fullscreen starts)
      function handleTouchStart(e) {
        if (!state.running) return; // Don't process touches before game starts
        
        e.preventDefault();
        e.stopPropagation();

        Array.from(e.changedTouches).forEach(touch => {
          const pos = getTouchPosition(touch);
          touches.set(touch.identifier, {
            startX: pos.x,
            startY: pos.y,
            currentX: pos.x,
            currentY: pos.y,
            startTime: performance.now(),
            isDrag: false
          });
        });
      }

      function handleTouchMove(e) {
        e.preventDefault();
        e.stopPropagation();
        if (!state.running) return;

        Array.from(e.changedTouches).forEach(touch => {
          const data = touches.get(touch.identifier);
          if (!data) return;

          const pos = getTouchPosition(touch);
          data.currentX = pos.x;
          data.currentY = pos.y;

          // Calculate horizontal drag distance
          const dragDistX = data.currentX - data.startX;
          const dragDistY = Math.abs(data.currentY - data.startY);

          // Mark as drag if moved beyond threshold
          if (!data.isDrag && (Math.abs(dragDistX) > DRAG_THRESHOLD || dragDistY > DRAG_THRESHOLD)) {
            data.isDrag = true;
          }
        });

        // Calculate drag velocity from all active touches
        let totalDrag = 0;
        let dragTouches = 0;
        touches.forEach(data => {
          if (data.isDrag) {
            const dragDist = data.currentX - data.startX;
            totalDrag += dragDist;
            dragTouches++;
          }
        });

        if (dragTouches > 0) {
          dragVelocity = Math.max(-1, Math.min(1, totalDrag * DRAG_SENSITIVITY));
          
          // Set keyboard keys based on drag direction with lower threshold for responsiveness
          if (dragVelocity < -0.05) {
            keys.left = true;
            keys.right = false;
          } else if (dragVelocity > 0.05) {
            keys.right = true;
            keys.left = false;
          } else {
            keys.left = false;
            keys.right = false;
          }
        }
      }

      function handleTouchEnd(e) {
        e.preventDefault();
        e.stopPropagation();
        if (!state.running) return;

        Array.from(e.changedTouches).forEach(touch => {
          const data = touches.get(touch.identifier);
          if (!data) return;

          const touchDuration = performance.now() - data.startTime;
          const dragDistX = Math.abs(data.currentX - data.startX);
          const dragDistY = Math.abs(data.currentY - data.startY);
          const totalDist = Math.sqrt(dragDistX * dragDistX + dragDistY * dragDistY);

          // It's a TAP if: quick duration AND minimal movement
          if (touchDuration < TAP_TIME_THRESHOLD && totalDist < DRAG_THRESHOLD) {
            keys.jump = true;
            // Reset jump after delay to allow repeated taps
            setTimeout(() => {
              keys.jump = false;
            }, 100);
          }

          touches.delete(touch.identifier);
        });

        // If no more touches, clear drag velocity and movement
        if (touches.size === 0) {
          dragVelocity = 0;
          keys.left = false;
          keys.right = false;
        } else {
          // Recalculate drag from remaining touches
          let totalDrag = 0;
          let dragTouches = 0;
          touches.forEach(data => {
            if (data.isDrag) {
              const dragDist = data.currentX - data.startX;
              totalDrag += dragDist;
              dragTouches++;
            }
          });

          if (dragTouches > 0) {
            dragVelocity = Math.max(-1, Math.min(1, totalDrag * DRAG_SENSITIVITY));
          } else {
            dragVelocity = 0;
            keys.left = false;
            keys.right = false;
          }
        }
      }

      function handleTouchCancel(e) {
        e.preventDefault();
        e.stopPropagation();
        Array.from(e.changedTouches).forEach(touch => {
          touches.delete(touch.identifier);
        });
        
        if (touches.size === 0) {
          dragVelocity = 0;
          keys.left = false;
          keys.right = false;
          keys.jump = false;
        }
      }

      // Attach touch listeners ONLY to canvas and stage
      // (NOT to body - that would interfere with buttons)
      // Touch controls only work when game is running
      canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
      canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
      canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
      canvas.addEventListener('touchcancel', handleTouchCancel, { passive: false });
      
      stage.addEventListener('touchstart', handleTouchStart, { passive: false });
      stage.addEventListener('touchmove', handleTouchMove, { passive: false });
      stage.addEventListener('touchend', handleTouchEnd, { passive: false });
      stage.addEventListener('touchcancel', handleTouchCancel, { passive: false });

      // Keyboard controls
      window.addEventListener('keydown', e => {
        const key = e.key.toLowerCase();
        if (['arrowleft', 'a'].includes(key)) {
          e.preventDefault();
          keys.left = true;
        }
        if (['arrowright', 'd'].includes(key)) {
          e.preventDefault();
          keys.right = true;
        }
        if (['arrowup', ' ', 'w'].includes(key)) {
          e.preventDefault();
          keys.jump = true;
        }
      });

      window.addEventListener('keyup', e => {
        const key = e.key.toLowerCase();
        if (['arrowleft', 'a'].includes(key)) keys.left = false;
        if (['arrowright', 'd'].includes(key)) keys.right = false;
        if (['arrowup', ' ', 'w'].includes(key)) keys.jump = false;
      });

      // Draw static preview on description page
      function drawPreview() {
        if (!previewCtx || !previewCanvas) return;
        
        const w = previewCanvas.width;
        const h = previewCanvas.height;
        const groundY = h - 100;
        
        // Background
        const bgGradient = previewCtx.createLinearGradient(0, 0, 0, h);
        bgGradient.addColorStop(0, '#b0d4f0');
        bgGradient.addColorStop(0.5, '#ffd6e8');
        bgGradient.addColorStop(1, '#ffb3d9');
        previewCtx.fillStyle = bgGradient;
        previewCtx.fillRect(0, 0, w, h);
        
        // Ground
        previewCtx.fillStyle = '#ffb3d9';
        previewCtx.fillRect(0, groundY + 100, w, h - groundY - 100);
        
        // Monkey (centered)
        const monkeyFrame = imageCache.monkeyFrames[0];
        if (monkeyFrame.complete && monkeyFrame.naturalWidth > 0) {
          previewCtx.drawImage(monkeyFrame, w/2 - 30, groundY, 60, 100);
        }
        
        // Some balloons
        const balloonImg = imageCache.balloons[0];
        if (balloonImg.complete && balloonImg.naturalWidth > 0) {
          previewCtx.drawImage(balloonImg, w/4, groundY - 100, 50, 65);
          previewCtx.drawImage(balloonImg, w/4 * 3, groundY - 150, 50, 65);
        }
        
        // Text
        previewCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        previewCtx.font = 'bold 32px Arial';
        previewCtx.textAlign = 'center';
        previewCtx.fillText('Happy 8th Birthday Henry!', w/2, 50);
      }

      async function startGameFlow() {
        try {
          if (state.running) return;
          
          logError('USER_ACTION', isEmbedded ? 'Auto-starting embedded game' : 'Start button clicked');
          
          // Hide description page
          if (descriptionPage) descriptionPage.classList.add('hidden');
          
          // Show game stage
          if (stage) stage.classList.remove('hidden');
          
          // Add class to body to prevent scrolling (only if not embedded)
          if (!isEmbedded) {
            document.body.classList.add('game-running');
          }
          
          // Request fullscreen on stage element (only if not embedded)
          if (!isEmbedded) {
            try {
              if (stage.requestFullscreen) {
                await stage.requestFullscreen();
                logError('FULLSCREEN', 'Fullscreen entered (standard)');
              } else if (stage.webkitRequestFullscreen) {
                await stage.webkitRequestFullscreen();
                logError('FULLSCREEN', 'Fullscreen entered (webkit)');
              } else if ((stage as any).mozRequestFullScreen) {
                await (stage as any).mozRequestFullScreen();
                logError('FULLSCREEN', 'Fullscreen entered (moz)');
              } else if ((stage as any).msRequestFullscreen) {
                await (stage as any).msRequestFullscreen();
                logError('FULLSCREEN', 'Fullscreen entered (ms)');
              } else {
                logError('FULLSCREEN', 'Fullscreen API not available');
              }
            } catch (err) {
              logError('FULLSCREEN', 'Fullscreen request failed', err);
            }
          }
          
          // Start game after a brief delay to ensure viewport is ready
          setTimeout(() => {
            startGame();
          }, isEmbedded ? 100 : 300);
        } catch (err) {
          logError('CRITICAL', 'Error in start game flow', err);
        }
      }

      startBtn?.addEventListener('click', startGameFlow);
      
      // Auto-start if embedded
      if (isEmbedded) {
        // Add embedded class to stage for proper styling
        if (stage) {
          stage.classList.add('embedded');
        }
        
        // When embedded, hide description page and show stage immediately
        setTimeout(() => {
          if (descriptionPage) descriptionPage.style.display = 'none';
        }, 50);
        
        // Wait for images to load, then auto-start
        Promise.all([
          ...imageCache.monkeyFrames.map(img => new Promise(resolve => { 
            img.onload = resolve; 
            img.onerror = resolve; 
          })),
          ...imageCache.balloons.map(img => new Promise(resolve => { 
            img.onload = resolve; 
            img.onerror = resolve; 
          })),
          new Promise(resolve => { 
            imageCache.number8Balloon.onload = resolve; 
            imageCache.number8Balloon.onerror = resolve; 
          }),
          ...imageCache.crocFrames.map(img => new Promise(resolve => { 
            img.onload = resolve; 
            img.onerror = resolve; 
          })),
        ]).then(() => {
          if (stage) stage.classList.remove('hidden');
          setTimeout(() => {
            startGameFlow();
          }, 200);
        });
      }

      restartBtn.addEventListener('click', () => {
        state.running = false;
        keys.left = false;
        keys.right = false;
        keys.jump = false;
        touches.clear();
        dragVelocity = 0;
        gameOverOverlay.classList.add('hidden');
        
        state.score = 0;
        state.lives = 3;
        state.monkey.x = state.canvasW / 2 - 30;
        state.monkey.y = state.groundY;
        state.monkey.vx = 0;
        state.monkey.vy = 0;
        state.monkey.isJumping = false;
        state.monkey.onGround = true;
        state.balloons = [];
        state.crocodiles = [];
        state.particles = [];
        state.effects = [];
        state.combo = 0;
        state.multiplier = 1;
        state.comboTimer = 0;
        state.shield = false;
        state.shieldTimer = 0;
        state.slowMotion = false;
        state.slowMotionTimer = 0;
        state.screenShake = 0;
        state.lastBalloonTime = 0;
        state.lastCrocTime = 0;
        state.lastComboTime = 0;
        state.gameSpeed = DIFFICULTY.baseGameSpeed;
        state.displayScore = 0;
        
        // Restart game
        setTimeout(() => {
          startGame();
        }, 300);
      });

      exitFullscreenBtn.addEventListener('click', () => {
        state.running = false;
        keys.left = false;
        keys.right = false;
        keys.jump = false;
        touches.clear();
        dragVelocity = 0;
        
        // Exit fullscreen
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        } else if (document.mozCancelFullScreen) {
          document.mozCancelFullScreen();
        } else if (document.msExitFullscreen) {
          document.msExitFullscreen();
        }
        
        // Return to description page
        setTimeout(() => {
          stage.classList.add('hidden');
          descriptionPage.classList.remove('hidden');
          document.body.classList.remove('game-running');
          gameOverOverlay.classList.add('hidden');
          
          // Reset game state
          state.score = 0;
          state.lives = 3;
          state.monkey.x = W / 2 - 30;
          state.monkey.y = GROUND_Y;
          state.balloons = [];
          state.crocodiles = [];
          state.particles = [];
          state.effects = [];
          drawPreview();
        }, 300);
      });

      function startGame() {
        try {
          logError('GAME_STATE', 'Starting game...');
          
          state.running = false;
          keys.left = false;
          keys.right = false;
          keys.jump = false;
          touches.clear();
          dragVelocity = 0;
          // Description page is already hidden, gameOverOverlay should be hidden
          if (gameOverOverlay) gameOverOverlay.classList.add('hidden');
          
          resizeCanvas();
          
          requestAnimationFrame(() => {
            try {
              state.running = true;
          state.score = 0;
          state.lives = 3;
          state.monkey.x = state.canvasW / 2 - 30;
          state.monkey.y = state.groundY;
          state.monkey.vy = 0;
          state.monkey.isJumping = false;
          state.monkey.onGround = true;
          state.monkey.walkFrame = 0;
          state.balloons = [];
          state.crocodiles = [];
          state.particles = [];
          state.effects = [];
          state.lastBalloonTime = 0;
          state.lastCrocTime = 0;
          state.gameSpeed = DIFFICULTY.baseGameSpeed;
          state.combo = 0;
          state.multiplier = 1;
          state.comboTimer = 0;
          state.shield = false;
          state.shieldTimer = 0;
          state.slowMotion = false;
          state.slowMotionTimer = 0;
          state.screenShake = 0;
          state.lastComboTime = 0;
          
          backgroundLayers.forEach(layer => layer.offset = 0);
          
          createDecorations();
          updateHud();
          state.lastTime = performance.now();
          
          logError('GAME_STATE', 'Game loop starting');
          requestAnimationFrame(loop);
            } catch (err) {
              logError('GAME_START', 'Error in game initialization', err);
            }
          });
        } catch (err) {
          logError('CRITICAL', 'Error in startGame()', err);
        }
      }

      function updateHud() {
        scoreEl.textContent = state.score;
        livesEl.textContent = state.lives;
        bestEl.textContent = state.best;
      }

      function checkCollision(rect1, rect2) {
        return rect1.x < rect2.x + rect2.width &&
               rect1.x + rect1.width > rect2.x &&
               rect1.y < rect2.y + rect2.height &&
               rect1.y + rect1.height > rect2.y;
      }

      function gameOver() {
        state.running = false;
        touches.clear();
        dragVelocity = 0;
        if (state.score > state.best) {
          state.best = state.score;
          localStorage.setItem('henryMonkeyBest', state.best.toString());
          gameOverTitle.textContent = 'üéâ New Best Score Henry! üéâ';
          gameOverText.innerHTML = `Amazing! You caught <strong>${state.score}</strong> balloons! Happy 8th Birthday!`;
        } else {
          gameOverTitle.textContent = 'Game Over!';
          gameOverText.innerHTML = `You caught <strong>${state.score}</strong> balloons! Happy 8th Birthday Henry!`;
        }
        finalScoreEl.textContent = state.score;
        gameOverOverlay.classList.remove('hidden');
      }

              function loop(now) {
                try {
                  if (!state.running) {
                    requestAnimationFrame(loop);
                    return;
                  }

                  if (!now) now = performance.now();
                  if (!state.lastTime) {
                    state.lastTime = now;
                    requestAnimationFrame(loop);
                    return;
                  }

                  // Calculate delta time with proper clamping for frame-rate independence
                  const rawDt = (now - state.lastTime) / 1000;
                  
                  // Skip if delta is too large (tab was inactive) or invalid
                  if (rawDt <= 0 || rawDt > 0.1) {
                    state.lastTime = now;
                    requestAnimationFrame(loop);
                    return;
                  }
                  
                  // Clamp delta time to prevent huge jumps (cap at 33ms = 30fps for stability)
                  const dt = Math.min(rawDt, 0.033);
                  state.lastTime = now;
        
        const currentW = state.canvasW;
        const currentH = state.canvasH;
        const currentGroundY = state.groundY;
        
        state.screenShake *= 0.9;

        if (state.shield) {
          state.shieldTimer -= dt;
          if (state.shieldTimer <= 0) state.shield = false;
        }
        if (state.slowMotion) {
          state.slowMotionTimer -= dt;
          if (state.slowMotionTimer <= 0) state.slowMotion = false;
        }
        
        state.comboTimer += dt;
        if (state.comboTimer > 2) {
          state.combo = 0;
          state.multiplier = 1;
        }
        
        const baseSpeed = DIFFICULTY.baseGameSpeed + (state.score * DIFFICULTY.speedIncrease);
        state.gameSpeed = state.slowMotion ? baseSpeed * 0.5 : baseSpeed;

        backgroundLayers.forEach(layer => {
          layer.offset += layer.speed * state.gameSpeed * dt * 60;
          if (layer.offset > currentW) layer.offset = 0;
        });

        state.monkey.vx = 0;
        if (keys.left && state.monkey.x > 0) {
          state.monkey.vx = -state.monkey.speed;
          state.monkey.walkFrame += dt * 10;
        }
        if (keys.right && state.monkey.x < currentW - state.monkey.width) {
          state.monkey.vx = state.monkey.speed;
          state.monkey.walkFrame += dt * 10;
        }

        if (keys.jump && state.monkey.onGround && !state.monkey.isJumping) {
          state.monkey.vy = state.jumpPower;
          state.monkey.onGround = false;
          state.monkey.isJumping = true;
        }

        state.monkey.vy += state.gravity * 60 * dt;
        state.monkey.y += state.monkey.vy * 60 * dt;

        if (state.monkey.y >= currentGroundY) {
          state.monkey.y = currentGroundY;
          state.monkey.vy = 0;
          state.monkey.onGround = true;
          state.monkey.isJumping = false;
        }

        state.monkey.x += state.monkey.vx * 60 * dt;
        state.monkey.x = Math.max(0, Math.min(currentW - state.monkey.width, state.monkey.x));

        state.decorations.forEach(d => {
          d.rotation += d.speed;
          d.y += (0.5 + d.depth * 0.5);
          if (d.y > currentH) d.y = -20;
        });

        const balloonSpawnRate = Math.max(
          DIFFICULTY.balloonSpawnMin, 
          DIFFICULTY.balloonSpawnBase - state.score * DIFFICULTY.balloonSpawnScaling
        );
        if (now - state.lastBalloonTime > balloonSpawnRate + Math.random() * 400) {
          const sideDrift = (Math.random() - 0.5) * 2;
          const startX = 50 + Math.random() * (currentW - 100);
          const rand = Math.random();
          state.balloons.push({
            x: startX,
            y: -80,
            speed: (2.5 + Math.random() * 2.5) * state.gameSpeed,
            color: balloonColors[Math.floor(Math.random() * balloonColors.length)],
            rotation: (Math.random() - 0.5) * 0.1,
            size: 45 + Math.random() * 25,
            isSpecial8: rand < 0.12,
            isGolden: rand >= 0.12 && rand < 0.20,
            isPowerUp: rand >= 0.92 && rand < 0.96,
            powerUpType: rand >= 0.92 && rand < 0.94 ? 'shield' : 'slowmo',
            driftSpeed: sideDrift,
            startX: startX,
            driftAmplitude: 40 + Math.random() * 50,
          });
          state.lastBalloonTime = now;
        }

        const crocSpawnRate = Math.max(
          DIFFICULTY.crocSpawnMin, 
          DIFFICULTY.crocSpawnBase - state.score * DIFFICULTY.crocSpawnScaling
        );
        if (now - state.lastCrocTime > crocSpawnRate + Math.random() * 800) {
          state.crocodiles.push({
            x: Math.random() > 0.5 ? -140 : currentW + 140,
            y: currentGroundY + 10,
            speed: (2 + Math.random() * 2) * state.gameSpeed,
            direction: Math.random() > 0.5 ? 1 : -1,
            walkFrame: 0,
          });
          state.lastCrocTime = now;
        }

        // Balloon updates
        for (let i = state.balloons.length - 1; i >= 0; i--) {
          const b = state.balloons[i];
          b.y += b.speed * 60 * dt;
          b.rotation += 0.03;
          
          if (b.driftSpeed !== undefined) {
            const progress = (b.y + 80) / (currentH + 80);
            b.x = b.startX + Math.sin(progress * Math.PI * 2.5) * b.driftAmplitude;
          }

          const balloonRect = {
            x: b.x + b.size * (1 - DIFFICULTY.collisionTolerance) / 2,
            y: b.y + b.size * (1 - DIFFICULTY.collisionTolerance) / 2,
            width: b.size * DIFFICULTY.collisionTolerance,
            height: b.size * 1.1 * DIFFICULTY.collisionTolerance
          };
          const monkeyRect = {
            x: state.monkey.x + state.monkey.width * (1 - DIFFICULTY.collisionTolerance) / 2,
            y: state.monkey.y + state.monkey.height * (1 - DIFFICULTY.collisionTolerance) / 2,
            width: state.monkey.width * DIFFICULTY.collisionTolerance,
            height: state.monkey.height * DIFFICULTY.collisionTolerance
          };

          if (checkCollision(balloonRect, monkeyRect)) {
            if (b.isPowerUp) {
              if (b.powerUpType === 'shield') {
                state.shield = true;
                state.shieldTimer = DIFFICULTY.shieldDuration;
                addEffect(state.monkey.x + state.monkey.width/2, state.monkey.y, 'üõ°Ô∏è SHIELD!', '#4169E1');
              } else if (b.powerUpType === 'slowmo') {
                state.slowMotion = true;
                state.slowMotionTimer = DIFFICULTY.slowMoDuration;
                addEffect(state.monkey.x + state.monkey.width/2, state.monkey.y, '‚è±Ô∏è SLOW MO!', '#FFD700');
              }
              state.balloons.splice(i, 1);
              createParticles(b.x + b.size/2, b.y + b.size/2, b.color);
              continue;
            }
            
            if (now - state.lastComboTime < 1000) {
              state.combo++;
              state.comboTimer = 0;
              if (state.combo > 1) {
                state.multiplier = Math.min(5, 1 + Math.floor(state.combo / 3));
                addEffect(state.monkey.x + state.monkey.width/2, state.monkey.y - 20, `COMBO x${state.multiplier}!`, '#FF6B9D');
              }
            } else {
              state.combo = 1;
              state.multiplier = 1;
            }
            state.lastComboTime = now;
            
            let points = b.isSpecial8 ? 2 : (b.isGolden ? 5 : 1);
            points *= state.multiplier;
            state.score += points;
            
            createParticles(b.x + b.size/2, b.y + b.size/2, b.color);
            if (points > 1) {
              addEffect(b.x + b.size/2, b.y, `+${points}`, '#FFD700');
            }
            
            if (points >= 5) {
              state.screenShake = 5;
            }
            
            state.balloons.splice(i, 1);
            updateHud();
            continue;
          }

          if (b.y > currentH) {
            state.balloons.splice(i, 1);
          }
        }

        // Crocodile updates
        for (let i = state.crocodiles.length - 1; i >= 0; i--) {
          const c = state.crocodiles[i];
          c.x += c.speed * 60 * dt * c.direction;
          c.walkFrame += dt * 10;

          const monkeyBottom = state.monkey.y + state.monkey.height;
          const crocTop = c.y;
          
          if (monkeyBottom >= crocTop - DIFFICULTY.crocJumpBuffer) {
            const crocRect = {
              x: c.x + 20,
              y: c.y + 15,
              width: 100,
              height: 40
            };
            const monkeyRect = {
              x: state.monkey.x + state.monkey.width * 0.15,
              y: state.monkey.y + state.monkey.height * 0.15,
              width: state.monkey.width * 0.7,
              height: state.monkey.height * 0.7
            };

            if (checkCollision(crocRect, monkeyRect)) {
              if (state.shield) {
                state.shield = false;
                state.shieldTimer = 0;
                addEffect(state.monkey.x + state.monkey.width/2, state.monkey.y, 'SHIELD!', '#00FF00');
                state.crocodiles.splice(i, 1);
                state.screenShake = 3;
                continue;
              }
              
              state.lives--;
              state.crocodiles.splice(i, 1);
              state.screenShake = 10;
              addEffect(state.monkey.x + state.monkey.width/2, state.monkey.y, 'OUCH!', '#FF0000');
              updateHud();
              if (state.lives <= 0) {
                gameOver();
                return;
              }
              state.monkey.x = currentW / 2 - 30;
              state.monkey.y = currentGroundY;
              state.monkey.vy = 0;
              continue;
            }
          }

          if ((c.direction > 0 && c.x > currentW + 140) || (c.direction < 0 && c.x < -140)) {
            state.crocodiles.splice(i, 1);
          }
        }
        
        // Particle updates
        for (let i = state.particles.length - 1; i >= 0; i--) {
          const p = state.particles[i];
          p.x += p.vx * dt * 60;
          p.y += p.vy * dt * 60;
          p.vy += 0.3 * dt * 60;
          p.life -= dt;
          p.alpha = Math.max(0, p.life / p.maxLife);
          if (p.life <= 0) {
            state.particles.splice(i, 1);
          }
        }
        
        // Effect updates
        for (let i = state.effects.length - 1; i >= 0; i--) {
          const e = state.effects[i];
          e.y -= 50 * dt;
          e.life -= dt;
          e.alpha = Math.min(1, e.life / e.maxLife);
          if (e.life <= 0) {
            state.effects.splice(i, 1);
          }
        }

                draw();
                requestAnimationFrame(loop);
              } catch (err) {
                logError('GAME_LOOP', 'Error in game loop', err);
                // Stop the game on critical loop error
                state.running = false;
              }
            }
      
      function createParticles(x, y, color) {
        for (let i = 0; i < 20; i++) {
          state.particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 250,
            vy: (Math.random() - 0.5) * 250,
            color: color,
            size: 3 + Math.random() * 5,
            life: 0.6 + Math.random() * 0.6,
            maxLife: 0.6 + Math.random() * 0.6,
            alpha: 1,
          });
        }
      }
      
      function addEffect(x, y, text, color) {
        state.effects.push({
          x: x,
          y: y,
          text: text,
          color: color,
          life: 1.5,
          maxLife: 1.5,
          alpha: 1,
          size: 28,
        });
      }

      function draw() {
        const currentW = state.canvasW;
        const currentH = state.canvasH;
        const currentGroundY = state.groundY;
        
        const shakeX = state.screenShake > 0 ? (Math.random() - 0.5) * state.screenShake : 0;
        const shakeY = state.screenShake > 0 ? (Math.random() - 0.5) * state.screenShake : 0;
        
        ctx.save();
        ctx.translate(shakeX, shakeY);
        
        ctx.clearRect(-shakeX, -shakeY, currentW, currentH);

        // Draw parallax background
        backgroundLayers.forEach((layer, index) => {
          const yStart = currentH * layer.yPos;
          const layerHeight = currentH * layer.height;
          
          ctx.fillStyle = layer.color;
          ctx.fillRect(0, yStart, currentW, layerHeight);
          
          if (index < 2) {
            ctx.save();
            ctx.globalAlpha = 0.4 - (index * 0.15);
            for (let i = 0; i < 3; i++) {
              const x = ((layer.offset * (i + 1)) % (currentW + 200)) - 100;
              const y = yStart + 20 + (i * 40);
              ctx.fillStyle = '#fff';
              ctx.beginPath();
              ctx.ellipse(x, y, 40, 25, 0, 0, Math.PI * 2);
              ctx.ellipse(x + 30, y - 10, 35, 20, 0, 0, Math.PI * 2);
              ctx.ellipse(x + 50, y, 40, 25, 0, 0, Math.PI * 2);
              ctx.fill();
            }
            ctx.restore();
          }
        });

        const bgGradient = ctx.createLinearGradient(0, currentH * 0.6, 0, currentH);
        bgGradient.addColorStop(0, '#ffd6e8');
        bgGradient.addColorStop(1, '#ffb3d9');
        ctx.fillStyle = bgGradient;
        ctx.fillRect(0, currentH * 0.6, currentW, currentH * 0.4);

        ctx.fillStyle = '#ffb3d9';
        ctx.fillRect(0, currentGroundY + 100, currentW, currentH - currentGroundY - 100);
        
        ctx.save();
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = '#ff8fb3';
        for (let i = 0; i < currentW; i += 80) {
          ctx.fillRect(i, currentGroundY + 100, 40, currentH - currentGroundY - 100);
        }
        ctx.restore();

        // Draw decorations
        state.decorations.forEach(d => {
          ctx.save();
          ctx.globalAlpha = 0.5 + d.depth * 0.5;
          ctx.translate(d.x, d.y);
          ctx.rotate(d.rotation);
          const size = d.size * (0.6 + d.depth * 0.4);
          
          if (d.type === 'confetti') {
            ctx.fillStyle = balloonColors[Math.floor(Math.random() * balloonColors.length)];
            ctx.fillRect(-size/2, -size/2, size, size);
          } else {
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
              const angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
              const x = Math.cos(angle) * size;
              const y = Math.sin(angle) * size;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
          }
          ctx.restore();
        });

        // Draw balloons with shadows
        state.balloons.forEach(b => {
          ctx.save();
          ctx.globalAlpha = 0.2;
          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.ellipse(b.x + b.size / 2, currentGroundY + 95, b.size * 0.3, b.size * 0.1, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
          
          ctx.save();
          ctx.translate(b.x + b.size / 2, b.y + b.size / 2);
          ctx.rotate(b.rotation);
          
          if (b.isGolden) {
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#FFD700';
          }
          
          if (b.isSpecial8 && imageCache.number8Balloon.complete) {
            ctx.drawImage(imageCache.number8Balloon, -b.size / 2, -b.size / 2, b.size, b.size * 1.3);
          } else if (b.isGolden) {
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.ellipse(0, 0, b.size / 2, b.size / 2 * 0.75, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFA500';
            ctx.beginPath();
            ctx.ellipse(0, -b.size * 0.1, b.size / 2 * 0.7, b.size / 2 * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFFF00';
            ctx.font = 'bold ' + (b.size * 0.3) + 'px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('‚≠ê', 0, 0);
          } else if (b.isPowerUp) {
            ctx.fillStyle = b.powerUpType === 'shield' ? '#4169E1' : '#FF6347';
            ctx.beginPath();
            ctx.ellipse(0, 0, b.size / 2, b.size / 2 * 0.75, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold ' + (b.size * 0.4) + 'px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(b.powerUpType === 'shield' ? 'üõ°Ô∏è' : '‚è±Ô∏è', 0, 0);
          } else {
            const balloonImg = imageCache.balloons[balloonColors.indexOf(b.color) % imageCache.balloons.length];
            if (balloonImg.complete) {
              ctx.drawImage(balloonImg, -b.size / 2, -b.size / 2, b.size, b.size * 1.3);
            } else {
              ctx.fillStyle = b.color;
              ctx.beginPath();
              ctx.ellipse(0, 0, b.size / 2, b.size / 2 * 0.75, 0, 0, Math.PI * 2);
              ctx.fill();
            }
          }
          ctx.shadowBlur = 0;
          ctx.restore();
        });
        
        // Draw particles
        state.particles.forEach(p => {
          ctx.save();
          ctx.globalAlpha = p.alpha;
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });
        
        // Draw effects
        state.effects.forEach(e => {
          ctx.save();
          ctx.globalAlpha = e.alpha;
          ctx.fillStyle = e.color;
          ctx.strokeStyle = '#FFFFFF';
          ctx.lineWidth = 4;
          ctx.font = `bold ${e.size}px Arial`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.strokeText(e.text, e.x, e.y);
          ctx.fillText(e.text, e.x, e.y);
          ctx.restore();
        });

        // Draw crocodiles with shadows
        state.crocodiles.forEach(c => {
          ctx.save();
          ctx.globalAlpha = 0.3;
          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.ellipse(c.x + 70, c.y + 75, 60, 15, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
          
          ctx.save();
          ctx.scale(c.direction, 1);
          const frameIndex = Math.floor(c.walkFrame) % imageCache.crocFrames.length;
          const crocImg = imageCache.crocFrames[frameIndex];
          if (crocImg.complete && crocImg.naturalWidth > 0) {
            ctx.drawImage(crocImg, c.direction > 0 ? c.x : -c.x - 140, c.y, 140, 70);
          } else {
            ctx.fillStyle = '#228b22';
            ctx.fillRect(c.direction > 0 ? c.x : -c.x - 140, c.y, 140, 70);
          }
          ctx.restore();
        });

        // Draw monkey shadow
        ctx.save();
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(state.monkey.x + state.monkey.width / 2, currentGroundY + 95, state.monkey.width * 0.4, state.monkey.width * 0.12, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Draw monkey shield
        if (state.shield) {
          ctx.save();
          ctx.strokeStyle = '#4169E1';
          ctx.lineWidth = 5;
          ctx.globalAlpha = 0.6 + Math.sin(Date.now() / 100) * 0.4;
          ctx.beginPath();
          ctx.arc(state.monkey.x + state.monkey.width / 2, state.monkey.y + state.monkey.height / 2, state.monkey.width / 2 + 12, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }
        
        // Draw monkey
        const monkeyFrameIndex = Math.floor(state.monkey.walkFrame) % imageCache.monkeyFrames.length;
        const monkeyImg = imageCache.monkeyFrames[monkeyFrameIndex];
        if (monkeyImg.complete && monkeyImg.naturalWidth > 0) {
          ctx.drawImage(monkeyImg, state.monkey.x, state.monkey.y, state.monkey.width, state.monkey.height);
        } else {
          ctx.fillStyle = '#d4a574';
          ctx.beginPath();
          ctx.arc(state.monkey.x + state.monkey.width / 2, state.monkey.y + state.monkey.height / 2, state.monkey.width / 2, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Draw combo multiplier
        if (state.multiplier > 1) {
          ctx.save();
          ctx.fillStyle = '#FF6B9D';
          ctx.strokeStyle = '#FFFFFF';
          ctx.lineWidth = 3;
          ctx.font = 'bold 22px Arial';
          ctx.textAlign = 'left';
          const comboText = `x${state.multiplier} COMBO!`;
          ctx.strokeText(comboText, 10, currentH - 25);
          ctx.fillText(comboText, 10, currentH - 25);
          ctx.restore();
        }
        
        // Draw power-up timers
        let timerY = 35;
        if (state.shield) {
          ctx.save();
          ctx.fillStyle = '#4169E1';
          ctx.strokeStyle = '#FFFFFF';
          ctx.lineWidth = 2;
          ctx.font = 'bold 18px Arial';
          ctx.textAlign = 'right';
          const shieldText = `üõ°Ô∏è ${Math.ceil(state.shieldTimer)}s`;
          ctx.strokeText(shieldText, currentW - 15, timerY);
          ctx.fillText(shieldText, currentW - 15, timerY);
          ctx.restore();
          timerY += 25;
        }
        if (state.slowMotion) {
          ctx.save();
          ctx.fillStyle = '#FFD700';
          ctx.strokeStyle = '#FFFFFF';
          ctx.lineWidth = 2;
          ctx.font = 'bold 18px Arial';
          ctx.textAlign = 'right';
          const slowText = `‚è±Ô∏è ${Math.ceil(state.slowMotionTimer)}s`;
          ctx.strokeText(slowText, currentW - 15, timerY);
          ctx.fillText(slowText, currentW - 15, timerY);
          ctx.restore();
        }
        
        ctx.restore();

        // Draw lives
        for (let i = 0; i < state.lives; i++) {
          ctx.fillStyle = '#ff6b9d';
          ctx.font = 'bold 32px Arial';
          ctx.fillText('üíù', 20 + i * 42, 38);
        }

        // Draw title
        ctx.save();
        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
        ctx.strokeStyle = '#FF6B9D';
        ctx.lineWidth = 2;
        ctx.font = 'bold 26px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.strokeText('Happy 8th Birthday Henry!', currentW / 2, 28);
        ctx.fillText('Happy 8th Birthday Henry!', currentW / 2, 28);
        ctx.restore();
      }
      
      resizeCanvas();
      draw();
      } catch (err) {
        logError('CRITICAL', 'Error in game initialization', err);
      }
    })();
  </script>
</body>
</html>
