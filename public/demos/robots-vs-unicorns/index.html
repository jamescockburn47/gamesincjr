<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Robots vs Unicorns: Neon Justice</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        body { margin: 0; overflow: hidden; background: #0d0221; touch-action: none; font-family: 'Press Start 2P', cursive; }
        canvas { display: block; width: 100%; height: 100%; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; font-size: 20px; pointer-events: none; z-index: 10; text-shadow: 3px 3px 0 #ff00cc; }
        #hp-bar-container { position: absolute; top: 20px; right: 20px; width: 200px; height: 20px; background: #333; border: 2px solid #fff; border-radius: 10px; overflow: hidden; }
        #hp-bar { width: 100%; height: 100%; background: linear-gradient(90deg, #00ff00, #adff2f); transition: width 0.2s; }
        #start-screen, #game-over-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(13, 2, 33, 0.85); backdrop-filter: blur(5px); display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; z-index: 20; }
        h1 { font-size: 40px; margin-bottom: 30px; text-align: center; line-height: 1.4; background: linear-gradient(to bottom, #fff, #ff00cc); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: 0 0 20px rgba(255,0,204,0.5); }
        button { background: #ff00cc; border: 4px solid #fff; padding: 20px 40px; color: white; font-family: 'Press Start 2P', cursive; font-size: 20px; cursor: pointer; box-shadow: 0 8px 0 #99007a; transition: transform 0.1s, box-shadow 0.1s; text-transform: uppercase; }
        button:active { transform: translateY(4px); box-shadow: 0 4px 0 #99007a; }
        .controls { margin-top: 40px; font-size: 12px; color: #aaa; text-align: center; line-height: 2; background: rgba(0,0,0,0.5); padding: 20px; border-radius: 10px; border: 1px solid #333; }
        .key { display: inline-block; padding: 5px 10px; border: 2px solid #666; border-radius: 4px; background: #222; color: #fff; margin: 0 5px; box-shadow: 0 3px 0 #000; }
        #combo-text { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%) scale(0); color: #ffff00; font-size: 40px; font-weight: bold; pointer-events: none; text-shadow: 4px 4px 0 #ff0000; z-index: 15; transition: transform 0.2s; }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <div>SCORE: <span id="score-val">0</span></div>
        <div style="font-size: 12px; color: #ccc; margin-top: 10px;">WAVE: <span id="wave-val">1</span></div>
    </div>
    <div id="hp-bar-container"><div id="hp-bar"></div></div>
    
    <div id="combo-text">COMBO!</div>

    <div id="start-screen">
        <h1>ROBOTS vs<br>UNICORNS</h1>
        <button id="startBtn">START MISSION</button>
        <div class="controls">
            <p>DESKTOP</p>
            <div><span class="key">SPACE</span> / <span class="key">↑</span> JUMP (Double Jump!)</div>
            <div style="margin-top:10px"><span class="key">X</span> / <span class="key">CLICK</span> FIRE LASER</div>
            <p style="margin-top:20px">MOBILE</p>
            <div>TAP LEFT = JUMP • TAP RIGHT = FIRE</div>
        </div>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1 style="color:#ff0055; -webkit-text-fill-color:#ff0055;">SYSTEM<br>FAILURE</h1>
        <div style="margin-bottom: 30px; font-size: 20px; text-align: center;">
            SCORE: <span id="final-score">0</span><br>
            <span style="font-size: 12px; color: #888; margin-top: 10px; display: block;">HIGHSCORE: <span id="high-score">0</span></span>
        </div>
        <button id="retryBtn">REBOOT</button>
    </div>

    <script>
        // --- Audio System (Synthesized) ---
        const AudioSys = {
            ctx: null,
            init: function() {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
            },
            playTone: function(freq, type, duration, vol=0.1) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            shoot: function() { 
                this.playTone(800, 'square', 0.1, 0.05); 
                setTimeout(() => this.playTone(600, 'square', 0.1, 0.05), 50);
            },
            jump: function() { this.playTone(300, 'sine', 0.2, 0.1); },
            explosion: function() { 
                this.playTone(100, 'sawtooth', 0.3, 0.1); 
                this.playTone(50, 'square', 0.4, 0.1);
            },
            powerup: function() {
                this.playTone(600, 'sine', 0.1, 0.1);
                setTimeout(() => this.playTone(900, 'sine', 0.1, 0.1), 100);
                setTimeout(() => this.playTone(1200, 'sine', 0.2, 0.1), 200);
            }
        };

        // --- Game Constants & State ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        let frames = 0;
        let score = 0;
        let highscore = localStorage.getItem('rvu_highscore') || 0;
        let wave = 1;
        let gameActive = false;
        let shake = 0;
        let gameSpeed = 1;
        
        const BASE_SPEED = 6;
        const GRAVITY = 0.7;
        
        // --- Entities ---
        const player = {
            x: 100, y: 0, w: 50, h: 50,
            dy: 0, jumpForce: -14,
            grounded: false,
            jumps: 0, maxJumps: 2,
            hp: 100, maxHp: 100,
            invincible: 0,
            color: '#fff'
        };

        let entities = []; // Bullets, Enemies, Particles
        let stars = [];
        let mountains = [];

        // --- Input ---
        const keys = { Jump: false, Shoot: false };

        // --- Initialization ---
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            
            // Ensure player stays on screen during resize
            if (player.y > height - 150) {
                 player.y = height - 150;
            }

            // Generate background mountains
            mountains = [];
            for(let i=0; i<width; i+=10) {
                mountains.push({
                    h: Math.random() * 100 + 50,
                    c: Math.random() > 0.5 ? '#1e1235' : '#251640'
                });
            }
        }

        function initGame() {
            if (!AudioSys.ctx) AudioSys.init();
            
            gameActive = true;
            score = 0;
            wave = 1;
            frames = 0;
            gameSpeed = 1;
            
            player.y = height - 150;
            player.dy = 0;
            player.hp = 100;
            player.invincible = 0;
            
            entities = [];
            
            // Initial Stars
            stars = Array(80).fill().map(() => ({
                x: Math.random() * width,
                y: Math.random() * height,
                size: Math.random() * 2 + 1,
                speed: Math.random() * 0.8 + 0.2
            }));

            updateUI();
            document.getElementById('hp-bar-container').classList.remove('hidden');
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            
            requestAnimationFrame(loop);
        }

        // --- Game Logic ---
        function spawnEnemy() {
            const isBoss = wave % 5 === 0 && frames % 500 === 0; // Mini-boss logic could go here
            const typeRand = Math.random();
            
            let type = 'walker';
            if (typeRand > 0.7) type = 'drone';
            if (typeRand > 0.9) type = 'dasher';

            const enemy = {
                id: Math.random(),
                group: 'enemy',
                type: type,
                x: width + 100,
                y: type === 'drone' ? height - 250 - Math.random() * 150 : height - 90,
                w: type === 'walker' ? 50 : 40,
                h: type === 'walker' ? 50 : 40,
                hp: type === 'walker' ? 2 : 1,
                vx: (type === 'dasher' ? 12 : 4) + (wave * 0.5),
                vy: type === 'drone' ? Math.sin(frames) * 2 : 0,
                color: type === 'dasher' ? '#ff3333' : '#a0a0a0'
            };
            entities.push(enemy);
        }

        function spawnBullet() {
            entities.push({
                group: 'bullet',
                x: player.x + 40,
                y: player.y + 25,
                w: 30, h: 8,
                vx: 20,
                life: 100
            });
            AudioSys.shoot();
        }

        function createParticles(x, y, count, color) {
            for(let i=0; i<count; i++) {
                entities.push({
                    group: 'particle',
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    life: 1.0,
                    color: color || '#fff',
                    size: Math.random() * 4 + 2
                });
            }
        }

        function showCombo() {
            const el = document.getElementById('combo-text');
            el.style.transform = 'translate(-50%, -50%) scale(1.5) rotate(-10deg)';
            el.style.display = 'block';
            setTimeout(() => el.style.transform = 'translate(-50%, -50%) scale(0)', 500);
        }

        function update() {
            if (!gameActive) return;
            frames++;
            
            // Difficulty Scaling
            if (frames % 1000 === 0) {
                wave++;
                gameSpeed += 0.1;
                // Heal on wave clear
                player.hp = Math.min(player.hp + 20, 100);
                AudioSys.powerup();
            }

            // --- Player Physics ---
            if (keys.JumpPressed) {
                if (player.grounded || player.jumps < player.maxJumps) {
                    player.dy = player.jumpForce;
                    player.grounded = false;
                    player.jumps++;
                    createParticles(player.x + 25, player.y + 50, 5, '#fff');
                    AudioSys.jump();
                }
                keys.JumpPressed = false; // Consume input
            }

            player.dy += GRAVITY;
            player.y += player.dy;

            // Ground collision
            const groundLevel = height - 90;
            if (player.y > groundLevel - player.h) {
                player.y = groundLevel - player.h;
                player.dy = 0;
                player.grounded = true;
                player.jumps = 0;
            }

            // Invincibility frames
            if (player.invincible > 0) player.invincible--;

            // Shooting
            if (keys.ShootPressed) {
                spawnBullet();
                keys.ShootPressed = false; // Semi-auto
            }

            // --- Entity Management ---
            // Spawning
            const spawnRate = Math.max(40, 120 - (wave * 10));
            if (frames % spawnRate === 0) spawnEnemy();

            // Update Entities
            for (let i = entities.length - 1; i >= 0; i--) {
                let e = entities[i];
                
                if (e.group === 'bullet') {
                    e.x += e.vx;
                    e.life--;
                    if (e.life <= 0) entities.splice(i, 1);
                    // Add trail
                    createParticles(e.x, e.y + 4, 1, '#0ff');
                }
                else if (e.group === 'enemy') {
                    e.x -= (e.vx * gameSpeed);
                    if (e.type === 'drone') e.y += Math.sin(frames * 0.1) * 2;
                    
                    // Cleanup offscreen
                    if (e.x < -100) entities.splice(i, 1);

                    // Collision: Bullet vs Enemy
                    entities.filter(b => b.group === 'bullet').forEach((b, bIdx) => {
                        if (rectIntersect(b, e)) {
                            // Hit!
                            e.hp--;
                            e.x += 10; // Knockback
                            // Remove bullet (find it in main array to be safe)
                            const realBIdx = entities.indexOf(b);
                            if (realBIdx > -1) entities.splice(realBIdx, 1);
                            
                            createParticles(e.x, e.y, 5, '#ffaa00');

                            if (e.hp <= 0) {
                                destroyEnemy(e, i);
                            }
                        }
                    });

                    // Collision: Player vs Enemy
                    if (rectIntersect(player, e) && player.invincible <= 0) {
                        takeDamage(20);
                        player.invincible = 60;
                        shake = 20;
                        createParticles(player.x, player.y, 20, '#ff0000');
                        destroyEnemy(e, i); // Enemy explodes on impact
                    }
                }
                else if (e.group === 'particle') {
                    e.x += e.vx;
                    e.y += e.vy;
                    e.vy += 0.5; // Gravity
                    e.life -= 0.05;
                    if (e.life <= 0) entities.splice(i, 1);
                }
            }

            // Background Stars
            stars.forEach(s => {
                s.x -= s.speed * gameSpeed;
                if (s.x < 0) s.x = width;
            });

            // Screen Shake Decay
            if (shake > 0) shake *= 0.9;
            if (shake < 0.5) shake = 0;

            updateUI();
        }

        function destroyEnemy(e, index) {
            // Check if already removed
            if (entities[index] !== e) return; 
            
            entities.splice(index, 1);
            score += 100 * wave;
            createParticles(e.x, e.y, 15, e.type === 'dasher' ? '#f00' : '#aaa');
            AudioSys.explosion();
            shake = 5;
            
            if (score % 1000 === 0) showCombo();
        }

        function takeDamage(amount) {
            player.hp -= amount;
            if (player.hp <= 0) {
                gameOver();
            }
        }

        function gameOver() {
            gameActive = false;
            if (score > highscore) {
                highscore = score;
                localStorage.setItem('rvu_highscore', highscore);
            }
            
            // Save score to backend
            fetch('/api/scores/save', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ gameSlug: 'robots-vs-unicorns', score: score })
            }).catch(() => {});

            document.getElementById('final-score').innerText = score;
            document.getElementById('high-score').innerText = highscore;
            document.getElementById('game-over-screen').classList.remove('hidden');
        }

        function draw() {
            // Camera Shake
            ctx.save();
            if (shake > 0) {
                const dx = (Math.random() - 0.5) * shake;
                const dy = (Math.random() - 0.5) * shake;
                ctx.translate(dx, dy);
            }

            // Background Gradient
            const grad = ctx.createLinearGradient(0, 0, 0, height);
            grad.addColorStop(0, '#0d0221');
            grad.addColorStop(1, '#2d1b4e');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, width, height);

            // Stars
            ctx.fillStyle = '#fff';
            stars.forEach(s => {
                ctx.globalAlpha = Math.random() * 0.5 + 0.5;
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.size, 0, Math.PI*2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // Mountains (Parallax)
            ctx.fillStyle = '#1e1235';
            ctx.beginPath();
            ctx.moveTo(0, height);
            for(let i=0; i<mountains.length; i++) {
                const m = mountains[i];
                const x = (i * 10) - (frames * 0.5 % width); // Parallax scroll
                // If wrapped
                const drawX = x < -10 ? x + width + 10 : x;
                ctx.lineTo(drawX, height - m.h);
            }
            ctx.lineTo(width, height);
            ctx.fill();

            // Ground (Cyber Grid)
            ctx.fillStyle = '#000';
            ctx.fillRect(0, height - 90, width, 90);
            ctx.strokeStyle = '#ff00cc';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, height - 90);
            ctx.lineTo(width, height - 90);
            // Grid lines
            const offset = (frames * BASE_SPEED * gameSpeed) % 60;
            for(let x = -offset; x < width; x += 60) {
                ctx.moveTo(x + 30, height - 90);
                ctx.lineTo(x - 60, height);
            }
            ctx.stroke();

            // --- Draw Entities ---
            // Player (Unicorn)
            if (gameActive || frames % 20 < 10) { // Blink if dead/waiting
                if (player.invincible % 10 < 5) {
                    drawUnicorn(player.x, player.y);
                }
            }

            entities.forEach(e => {
                if (e.group === 'enemy') drawEnemy(e);
                if (e.group === 'bullet') {
                    ctx.fillStyle = '#0ff';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#0ff';
                    ctx.fillRect(e.x, e.y, e.w, e.h);
                    ctx.shadowBlur = 0;
                }
                if (e.group === 'particle') {
                    ctx.fillStyle = e.color;
                    ctx.globalAlpha = e.life;
                    ctx.fillRect(e.x, e.y, e.size, e.size);
                    ctx.globalAlpha = 1;
                }
            });

            ctx.restore();

            if (gameActive) requestAnimationFrame(draw);
        }

        function drawUnicorn(x, y) {
            ctx.save();
            ctx.translate(x, y);
            
            // Rainbow Trail
            if (player.dy !== 0) {
                for(let i=0; i<3; i++) {
                    ctx.fillStyle = `hsl(${(frames * 10 + i*30) % 360}, 100%, 50%)`;
                    ctx.fillRect(-10 - i*5, 10 + i*2, 10, 30);
                }
            }

            // Body
            ctx.fillStyle = '#fff';
            ctx.shadowColor = '#ff00cc';
            ctx.shadowBlur = 15;
            ctx.fillRect(0, 10, 40, 30);
            
            // Head
            ctx.fillRect(25, 0, 20, 25);
            
            // Horn
            ctx.fillStyle = '#ffd700'; // Gold
            ctx.beginPath();
            ctx.moveTo(40, 5);
            ctx.lineTo(55, -10);
            ctx.lineTo(45, 10);
            ctx.fill();

            // Mane
            ctx.fillStyle = `hsl(${frames * 5 % 360}, 100%, 60%)`;
            ctx.fillRect(20, -5, 8, 25);

            // Eye
            ctx.fillStyle = '#000';
            ctx.fillRect(35, 5, 4, 4);

            ctx.shadowBlur = 0;
            ctx.restore();
        }

        function drawEnemy(e) {
            ctx.save();
            ctx.translate(e.x, e.y);
            
            if (e.type === 'drone') {
                // Floating Drone
                ctx.fillStyle = '#444';
                ctx.beginPath();
                ctx.arc(20, 20, 15, 0, Math.PI*2);
                ctx.fill();
                // Pulsing red eye
                ctx.fillStyle = `rgba(255, 0, 0, ${Math.abs(Math.sin(frames * 0.1))})`;
                ctx.shadowColor = 'red';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(20, 20, 6, 0, Math.PI*2);
                ctx.fill();
                ctx.shadowBlur = 0;
                // Propeller
                ctx.fillStyle = '#888';
                ctx.fillRect(0, -5, 40, 4);
            } else {
                // Walker/Dasher
                ctx.fillStyle = e.color;
                ctx.fillRect(0, 0, e.w, e.h);
                // Face
                ctx.fillStyle = '#000';
                ctx.fillRect(e.w - 15, 10, 10, 5); // Eye visor
                ctx.fillStyle = '#f00';
                ctx.fillRect(e.w - 12, 12, 4, 2); // Glow
                // Tread
                ctx.fillStyle = '#222';
                const treadOffset = (frames * 0.5) % 10;
                ctx.beginPath();
                ctx.arc(e.w/2, e.h, 10, 0, Math.PI*2); // Wheel
                ctx.fill();
            }
            ctx.restore();
        }

        function updateUI() {
            document.getElementById('score-val').innerText = Math.floor(score);
            document.getElementById('wave-val').innerText = wave;
            document.getElementById('hp-bar').style.width = player.hp + '%';
            
            // Color HP bar based on health
            const hpBar = document.getElementById('hp-bar');
            if (player.hp < 30) hpBar.style.background = '#ff0000';
            else if (player.hp < 60) hpBar.style.background = '#ffff00';
            else hpBar.style.background = 'linear-gradient(90deg, #00ff00, #adff2f)';
        }

        function loop() {
            update();
            if (gameActive) draw();
        }

        function rectIntersect(r1, r2) {
            return !(r2.x > r1.x + r1.w || 
                     r2.x + r2.w < r1.x || 
                     r2.y > r1.y + r1.h || 
                     r2.y + r2.h < r1.y);
        }

        // --- Input Listeners ---
        const handleInput = (code, down) => {
            if (code === 'Space' || code === 'ArrowUp' || code === 'KeyW') {
                if (down && !keys.Jump) keys.JumpPressed = true;
                keys.Jump = down;
            }
            if (code === 'KeyX' || code === 'Enter' || code === 'Click') {
                if (down && !keys.Shoot) keys.ShootPressed = true;
                keys.Shoot = down;
            }
        };

        // Focus management - ensure canvas/window receives events
        window.addEventListener('click', () => window.focus());

        window.addEventListener('keydown', e => {
            // Prevent default scrolling for game keys
            if(['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
                e.preventDefault();
            }
            handleInput(e.code, true);
        });
        
        window.addEventListener('keyup', e => handleInput(e.code, false));
        
        // Touch
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            for(let i=0; i<e.touches.length; i++) {
                const t = e.touches[i];
                if (t.clientX < width/2) handleInput('Space', true);
                else handleInput('Click', true);
            }
        });
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            // Simple clear for now, ideally track touch IDs
            keys.Jump = false;
            keys.Shoot = false;
        });
        
        canvas.addEventListener('mousedown', () => handleInput('Click', true));
        canvas.addEventListener('mouseup', () => handleInput('Click', false));

        document.getElementById('startBtn').addEventListener('click', initGame);
        document.getElementById('retryBtn').addEventListener('click', initGame);

        // Boot
        resize();
        window.addEventListener('resize', resize);
        draw(); // Initial render (title screen bg)

    </script>
</body>
</html>
